<!doctype html><html lang=en-US dir=ltr><head><meta charset=utf-8><meta name=viewport content="initial-scale=1,width=device-width"><link rel=icon type=image/png sizes=32x32 href=/blog/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/blog/favicons/favicon-16x16.png><link rel="shortcut icon" href=/blog/favicons/favicon.ico><title>Considering options | Anaminus.Blog</title><meta name=twitter:card content="summary"><meta name=twitter:title content="Considering options | Anaminus.Blog"><meta name=twitter:description content="How to implement an Optional type in Go."><meta name=twitter:image content="https://anaminus.github.io/blog/favicons/favicon-512x512.png"><meta property="og:type" content="website"><meta property="og:title" content="Considering options | Anaminus.Blog"><meta property="og:description" content="How to implement an Optional type in Go."><meta property="og:image" content="https://anaminus.github.io/blog/favicons/favicon-512x512.png"><link rel=stylesheet href=/blog/main.min.8856ad9922a20bcadfe4d0845af8f0906dea160014c30c6fe73da54094a38c6f.css integrity="sha256-iFatmSKiC8rf5NCEWvjwkG3qFgAUwwxv5z2lQJSjjG8=" crossorigin=anonymous></head><body><header><a href=https://anaminus.github.io/blog/><svg class="header" width="43" height="9" viewBox="0 0 43 9"><title>Logo with title ".Blog"</title><path class="logo" d="m2 1v1H1v3h1v3h1V7h1v1h1V5h1V2H5V1H4v1H3V1zm0 2h1v1H2zm2 0h1v1H4z"/><path class="title" d="m13 1v7h4V7h-3V5h3V4h-3V2h3V1zm4 1v2h1V2zm0 3v2h1V5zm2-2v5h5V7h-4V3zm7 0v1h3V3zm3 1v3h1V4zm0 3h-3v1h3zm-3 0V4h-1v3zm6-4v1h4V3zm0 1h-1v3h1zm0 3v1h3V7zm3 0h1V5h-3v1h2zM9 7v1h1V7z"/><path class="cursor" d="m37 8h5v1h-5z"/></svg></a></header><main><nav><a href=https://anaminus.github.io/blog/posts/>Posts</a></nav><article><header><div class=title><h1>Considering options</h1><span class=date>Published on <time>2022-11-10</time></span></div><div class=subtitle><div class=description>How to implement an Optional type in Go.</div><span class=tags><a class=tag href=https://anaminus.github.io/blog/tags/golang/>#golang</a></span></div></header><p>I&rsquo;m in the middle of rewriting <a href=https://github.com/robloxapi/rbxfile>rbxfile</a>. A rewrite gives the
opportunity to right any wrongs.</p><p>One of the wrongs was my approach to Optional types. That is not to say that it
was incorrect, but it perhaps wasn&rsquo;t considered as carefully as it could have
been. Moreover, Go didn&rsquo;t have generics at the time, so there were fewer good
options available.</p><p>I currently have the Optional type implemented as a struct with a Type and a
Value field:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>Optional</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>typ</span><span class=w>   </span><span class=nx>Type</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>A Type is an enum representing a limited set of data types. A Value is an
interface containing a value of one of these types (a part of the contract is a
<code>Type()</code> method that returns the Type).</p><p>The some-ness of the Optional is indicated by the Value being non-nil. When it
is nil, the additional Type field is included so that a none-y Optional still
has a type. These fields are encapsulated to prevent things from getting weird.</p><p>Overall, pretty clunky. This is what we must do when generics aren&rsquo;t a thing.</p><p>Once generics landed, more possibilities became available. I tried grappling
with them a few months ago, but wasn&rsquo;t able to settle on anything. Not only was
I still figuring out generics, but there were always questions of &ldquo;What if this
implementation prevents me from using it in some necessary way? What if that
other implementation does the same thing, but for different requirements?&rdquo; The
real problem was that the requirements were poorly understood.</p><p>Now that I&rsquo;m rewriting the whole thing, I&rsquo;m able to take a step back and look at
the full picture. With a better view, I was able to come up with the following
requirement:</p><ul><li>I need to be able to type-switch over the inner type of an optional.</li></ul><p>That is, once a type has been determined to be <em>some kind</em> of Optional, I then
need to be able to determine that inner type. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>InspectValue</span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>switch</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>value</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>String</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;it&#39;s a string!&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>CFrame</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;it&#39;s a CFrame!&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Optional</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;it&#39;s optional!&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>v</span><span class=p>,</span><span class=w> </span><span class=nx>_</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>value</span><span class=p>.</span><span class=nf>Optional</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>_</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>v</span><span class=p>.(</span><span class=nx>Optional</span><span class=p>);</span><span class=w> </span><span class=p>!</span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>InspectValue</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This would recursively cover the following types:</p><ul><li><code>String</code></li><li><code>CFrame</code></li><li><code>Optional&lt;String></code></li><li><code>Optional&lt;CFrame></code></li></ul><p>The keyword being &ldquo;recursive&rdquo;. It&rsquo;s a lot easier if I don&rsquo;t have to reimplement
cases for each type of Optional that might crop up.</p><p>Once you have at least one requirement, it becomes infinitely easier to think
about the implementation. Whether it is good or bad can actually be answered.</p><p>Additionally, the various possible implementations for Optional have had time to
gestate in my mind. I was able to determine that there are two separated
concerns: an interface for the optional, and the implementations of this
interface.</p><h2 id=interfaces>Interfaces</h2><p>On the interface side, there are two possibilities:</p><ul><li>Typed interface</li><li>Untyped interface</li></ul><h3 id=typed-interface>Typed interface</h3><p>The typed interface has a method where the optional returns its inner type
directly. It can be defined like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>TypedOptional</span><span class=p>[</span><span class=nx>T</span><span class=w> </span><span class=kt>any</span><span class=p>]</span><span class=w> </span><span class=kd>interface</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>TypedOptional</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=nx>T</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>That is, for an Optional with inner type T, the method returns a value of type
T.</p><p>How does this fit into the requirements? Well, not very well. It isn&rsquo;t possible
to have <em>any kind</em> of optional as a case. The inner type of the optional must be
known beforehand. The inspector would have to look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>InspectValue</span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=nx>Value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>switch</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>value</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>String</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;it&#39;s a string!&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>CFrame</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;it&#39;s a CFrame!&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Optional</span><span class=p>[</span><span class=nx>String</span><span class=p>]:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;it&#39;s a string?&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>v</span><span class=p>,</span><span class=w> </span><span class=nx>_</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>value</span><span class=p>.</span><span class=nf>Optional</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>InspectValue</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>case</span><span class=w> </span><span class=nx>Optional</span><span class=p>[</span><span class=nx>CFrame</span><span class=p>]:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;it&#39;s a CFrame?&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>v</span><span class=p>,</span><span class=w> </span><span class=nx>_</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>value</span><span class=p>.</span><span class=nf>Optional</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>InspectValue</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Now, if I did need this kind of switching, then this interface would be great
to have. For now, though, I&rsquo;ll keep it off to the side.</p><h3 id=untyped-interface>Untyped interface</h3><p>The untyped interface has a similar method, except that the value is returned
through an empty interface:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>UntypedOptional</span><span class=w> </span><span class=kd>interface</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>UntypedOptional</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=kt>any</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Unlike the typed variation, this meets the requirements quite nicely. The
interface has no type parameters, and the method returns an interface that can
be type-switched on.</p><h2 id=implementations>Implementations</h2><p>On the implementation side, there are also two possibilities:</p><ul><li>Unified</li><li>Separated</li></ul><p>Something to note is that both implementations can implement either kind of
interface.</p><h3 id=unified-type>Unified type</h3><p>The unified implementation consists of one type that embeds the state of the
Optional.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>UnifiedOptional</span><span class=p>[</span><span class=nx>T</span><span class=w> </span><span class=kt>any</span><span class=p>]</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>Value</span><span class=w> </span><span class=nx>T</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>Ok</span><span class=w>    </span><span class=kt>bool</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Implementing each interface is straightforward:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>o</span><span class=w> </span><span class=nx>UnifiedOptional</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span><span class=w> </span><span class=nf>UntypedOptional</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=kt>any</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>o</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span><span class=w> </span><span class=nx>o</span><span class=p>.</span><span class=nx>Ok</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>o</span><span class=w> </span><span class=nx>UnifiedOptional</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span><span class=w> </span><span class=nf>TypedOptional</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=nx>T</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>o</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span><span class=w> </span><span class=nx>o</span><span class=p>.</span><span class=nx>Ok</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Then I can create some constructors for each kind of optional. Two for Some and
None directly, and then another for specifying indirectly via boolean:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nx>UnifiedSome</span><span class=p>[</span><span class=nx>T</span><span class=w> </span><span class=kt>any</span><span class=p>](</span><span class=nx>value</span><span class=w> </span><span class=nx>T</span><span class=p>)</span><span class=w> </span><span class=nx>UnifiedOptional</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>UnifiedOptional</span><span class=p>[</span><span class=nx>T</span><span class=p>]{</span><span class=nx>Value</span><span class=p>:</span><span class=w> </span><span class=nx>value</span><span class=p>,</span><span class=w> </span><span class=nx>Ok</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nx>UnifiedNone</span><span class=p>[</span><span class=nx>T</span><span class=w> </span><span class=kt>any</span><span class=p>]()</span><span class=w> </span><span class=nx>UnifiedOptional</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>UnifiedOptional</span><span class=p>[</span><span class=nx>T</span><span class=p>]{</span><span class=nx>Ok</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nx>UnifiedNewOptional</span><span class=p>[</span><span class=nx>T</span><span class=w> </span><span class=kt>any</span><span class=p>](</span><span class=nx>value</span><span class=w> </span><span class=nx>T</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=nx>UnifiedOptional</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>UnifiedOptional</span><span class=p>[</span><span class=nx>T</span><span class=p>]{</span><span class=nx>Value</span><span class=p>:</span><span class=w> </span><span class=nx>value</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=p>:</span><span class=w> </span><span class=nx>ok</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>var</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>UnifiedDirectSome</span><span class=w>   </span><span class=p>=</span><span class=w> </span><span class=nf>UnifiedSome</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>UnifiedDirectNone</span><span class=w>   </span><span class=p>=</span><span class=w> </span><span class=nx>UnifiedNone</span><span class=p>[</span><span class=kt>int</span><span class=p>]()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>UnifiedIndirectSome</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>UnifiedNewOptional</span><span class=p>(</span><span class=mi>42</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>UnifiedIndirectNone</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>UnifiedNewOptional</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><h3 id=separated-types>Separated types</h3><p>The separated implementation consists of separate types for Some and None:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>SeparatedNone</span><span class=p>[</span><span class=nx>T</span><span class=w> </span><span class=kt>any</span><span class=p>]</span><span class=w> </span><span class=kd>struct</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>type</span><span class=w> </span><span class=nx>SeparatedSome</span><span class=p>[</span><span class=nx>T</span><span class=w> </span><span class=kt>any</span><span class=p>]</span><span class=w> </span><span class=kd>struct</span><span class=p>{</span><span class=w> </span><span class=nx>Value</span><span class=w> </span><span class=nx>T</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Each type implements each interface:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>o</span><span class=w> </span><span class=nx>SeparatedNone</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span><span class=w> </span><span class=nf>UntypedOptional</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=kt>any</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>v</span><span class=w> </span><span class=nx>T</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>v</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>o</span><span class=w> </span><span class=nx>SeparatedNone</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span><span class=w> </span><span class=nf>TypedOptional</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=nx>T</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>v</span><span class=w> </span><span class=nx>T</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>v</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>o</span><span class=w> </span><span class=nx>SeparatedSome</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span><span class=w> </span><span class=nf>UntypedOptional</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=kt>any</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>o</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>o</span><span class=w> </span><span class=nx>SeparatedSome</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span><span class=w> </span><span class=nf>TypedOptional</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=nx>T</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>o</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Here, I only need one constructor, for specifying indirectly. Direct optionals
can be created via their respective composite literal:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nx>SeparatedNewOptional</span><span class=p>[</span><span class=nx>T</span><span class=w> </span><span class=kt>any</span><span class=p>](</span><span class=nx>value</span><span class=w> </span><span class=nx>T</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=nx>TypedOptional</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=nx>SeparatedSome</span><span class=p>[</span><span class=nx>T</span><span class=p>]{</span><span class=nx>Value</span><span class=p>:</span><span class=w> </span><span class=nx>value</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=nx>SeparatedNone</span><span class=p>[</span><span class=nx>T</span><span class=p>]{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>var</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>SeparatedDirectSome</span><span class=w>   </span><span class=p>=</span><span class=w> </span><span class=nx>SeparatedSome</span><span class=p>{</span><span class=nx>Value</span><span class=p>:</span><span class=w> </span><span class=mi>42</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>SeparatedDirectNone</span><span class=w>   </span><span class=p>=</span><span class=w> </span><span class=nx>SeparatedNone</span><span class=p>[</span><span class=kt>int</span><span class=p>]{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>SeparatedIndirectSome</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>SeparatedNewOptional</span><span class=p>(</span><span class=mi>42</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>SeparatedIndirectNone</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>SeparatedNewOptional</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><h2 id=pick-something>Pick something</h2><p>The separated implementation seems like the most elegant. It&rsquo;s nice that the
state of the optional is stored in the type instead of as data.</p><p>The drawback is that it wouldn&rsquo;t work well with only the untyped interface. If I
wanted the option to assert specific types of optionals, like <code>Optional[String]</code>
or <code>Optional[CFrame]</code>, I wouldn&rsquo;t be able to, because those types don&rsquo;t exist. I
would have to assume the state of the optional as well as the type, such as
<code>Some[String]</code> or <code>None[CFrame]</code>.</p><p>However, if I elect to have both the typed and untyped interfaces at the same
time, then this option remains open. Each interface requires a separate method,
and each type implements both methods. To assert, I just have to use the typed
interface instead of an implementation, such as <code>TypedOptional[CFrame]</code>.
Interestingly, this still leaves the option of asserting specific states, too.</p><p>Can you get anymore flexible? Yes, actually. There&rsquo;s still the cases of
optionals with a specific state, but any type. This can be done by extending the
untyped interface with two more:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>SomeOptional</span><span class=w> </span><span class=kd>interface</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>UntypedOptional</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>Some</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>type</span><span class=w> </span><span class=nx>NoneOptional</span><span class=w> </span><span class=kd>interface</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>UntypedOptional</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>None</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>o</span><span class=w> </span><span class=nx>SeparatedNone</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span><span class=w> </span><span class=nf>None</span><span class=p>()</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=p>(</span><span class=nx>o</span><span class=w> </span><span class=nx>SeparatedSome</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span><span class=w> </span><span class=nf>Some</span><span class=p>()</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span></code></pre></div><p>With these final additions, cases for all possible combinations can be made:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>switch</span><span class=w> </span><span class=nx>value</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=nx>T</span><span class=p>:</span><span class=w>                </span><span class=c1>// T</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=kt>any</span><span class=p>:</span><span class=w>              </span><span class=c1>// ?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=nx>None</span><span class=p>[</span><span class=nx>T</span><span class=p>]:</span><span class=w>          </span><span class=c1>// None&lt;T&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=nx>NoneOptional</span><span class=p>:</span><span class=w>     </span><span class=c1>// None&lt;?&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=nx>Some</span><span class=p>[</span><span class=nx>T</span><span class=p>]:</span><span class=w>          </span><span class=c1>// Some&lt;T&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=nx>SomeOptional</span><span class=p>:</span><span class=w>     </span><span class=c1>// Some&lt;?&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=nx>TypedOptional</span><span class=p>[</span><span class=nx>T</span><span class=p>]:</span><span class=w> </span><span class=c1>// Optional&lt;T&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=nx>UntypedOptional</span><span class=p>:</span><span class=w>  </span><span class=c1>// Optional&lt;?&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Now the problem is simply deciding on actual names for all of thes-</p><p>Maybe I&rsquo;ll reconsider&mldr;</p></article></main><footer><span class=license>Content is licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA-4.0</a><a class=feed-icon title="RSS feed" href=https://anaminus.github.io/blog/index.xml><svg width="128" height="128" viewBox="0 0 256 256"><path d="m92 189a24 24 0 01-24 24 24 24 0 01-24-24 24 24 0 0124-24 24 24 0 0124 24z"/><path d="m160 213h-34a82 82 0 00-82-82V97a116 116 0 01116 116z"/><path d="M184 213A140 140 0 0044 73V38a175 175 0 01175 175z"/></svg></a></span>
<span class=publication><svg viewBox="0 0 7 7" width="7" height="7"><path d="m2 0v1H1v3h1v3h1V6h1v1h1V4h1V1H5V0H4v1H3V0zm0 2h1v1H2zm2 0h1v1H4z"/></svg> 2022â€“2025 <a href=https://anaminus.github.io/>Anaminus</a></span></footer></body></html>