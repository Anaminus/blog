<!doctype html><html lang=en-US dir=ltr><head><meta charset=utf-8><meta name=viewport content="initial-scale=1,width=device-width"><link rel=icon type=image/png sizes=32x32 href=/blog/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/blog/favicons/favicon-16x16.png><link rel="shortcut icon" href=/blog/favicons/favicon.ico><title>Tiny UVs | Anaminus.Blog</title><meta name=twitter:card content="summary"><meta name=twitter:title content="Tiny UVs | Anaminus.Blog"><meta name=twitter:description content="Making minimal and efficient UVs in Blender for Roblox."><meta name=twitter:image content="https://anaminus.github.io/blog/favicons/favicon-512x512.png"><meta property="og:type" content="website"><meta property="og:title" content="Tiny UVs | Anaminus.Blog"><meta property="og:description" content="Making minimal and efficient UVs in Blender for Roblox."><meta property="og:image" content="https://anaminus.github.io/blog/favicons/favicon-512x512.png"><link rel=stylesheet href=/blog/main.min.d44314867109fd1d095a61348ef92643a7f78532ebd601a156b2d85ef6e4522e.css integrity="sha256-1EMUhnEJ/R0JWmE0jvkmQ6f3hTLr1gGhVrLYXvbkUi4=" crossorigin=anonymous></head><body><header><a href=https://anaminus.github.io/blog/><svg class="header" width="43" height="9" viewBox="0 0 43 9"><title>Logo with title ".Blog"</title><path class="logo" d="m2 1v1H1v3h1v3h1V7h1v1h1V5h1V2H5V1H4v1H3V1zm0 2h1v1H2zm2 0h1v1H4z"/><path class="title" d="m13 1v7h4V7h-3V5h3V4h-3V2h3V1zm4 1v2h1V2zm0 3v2h1V5zm2-2v5h5V7h-4V3zm7 0v1h3V3zm3 1v3h1V4zm0 3h-3v1h3zm-3 0V4h-1v3zm6-4v1h4V3zm0 1h-1v3h1zm0 3v1h3V7zm3 0h1V5h-3v1h2zM9 7v1h1V7z"/><path class="cursor" d="m37 8h5v1h-5z"/></svg></a></header><main><nav><a href=https://anaminus.github.io/blog/posts/>Posts</a></nav><article><header><div class=title><h1>Tiny UVs</h1><span class=date>Published on <time>2022-09-24</time></span></div><div class=subtitle><div class=description>Making minimal and efficient UVs in Blender for Roblox.</div><span class=tags><a class=tag href=https://anaminus.github.io/blog/tags/roblox/>#roblox</a>
<a class=tag href=https://anaminus.github.io/blog/tags/blender/>#blender</a>
<a class=tag href=https://anaminus.github.io/blog/tags/gamedev/>#gamedev</a></span></div></header><p>You want to produce meshes with simple, solid color textures. Because the colors
are solid, you should be able to get away with using small textures. Tiny
textures. Single-digit resolution textures. Possible, right?</p><p>The problem: Roblox applies linear interpolation to its textures. Here is a
2-by-1 Decal, where the left pixel is white, and the right pixel is black:</p><figure><img src=/blog/posts/tiny-uv/fig1.png></figure><p>Indeed, the left side is white, and the right side is black, but in between,
there is a smooth, linear interpolation from one pixel to the other.</p><p>When constructing UVs for a mesh, we&rsquo;ll have to find a way around this. Let&rsquo;s
head over to Blender, and work on a simple plane mesh:</p><figure><img src=/blog/posts/tiny-uv/fig2.png></figure><p>The interpolation of the texture should be set to <strong>Linear</strong>, and the extension
should be set to <strong>Repeat</strong>. This will match how Roblox renders textures on
MeshParts. When we import it into Roblox, it looks mostly similar:</p><figure><img src=/blog/posts/tiny-uv/fig3.png></figure><p>Notably, the left side begins to fade towards black, while the right side fades
towards white, which proves that the texture repeats. So we&rsquo;ll be able to use
Blender to get a rough idea of what Roblox will render.</p><p>So how do we produce solid colors? We can&rsquo;t just cover the whole pixel with a
face, because half of the pixel is always interpolating to its neighbor:</p><figure><img src=/blog/posts/tiny-uv/fig4.png></figure><p>To get a solid color, the coordinates have to be in the exact center of the
pixel:</p><figure><img src=/blog/posts/tiny-uv/fig5.png></figure><p>Two faces, each using one color:</p><figure><img src=/blog/posts/tiny-uv/fig6.png></figure><p>But does it work in Roblox?</p><figure><img src=/blog/posts/tiny-uv/fig7.png></figure><p>Indeed! To compare the colors, the top squares are regular Parts, while the
bottom squares are the mesh.</p><p>UV coordinates are reused for SurfaceAppearance textures, so this technique can
be used to set the roughness and metalness of surfaces as well:</p><figure><img src=/blog/posts/tiny-uv/fig8.png></figure><p><strong>Tip:</strong> To set the coordinates of many faces at once, select all the faces, use
the scale tool, and set the scale amounts to 0. This will move all vertices to a
single location, which you can then move to the center of the desired pixel.</p><p><video src=/blog/posts/tiny-uv/fig9.webm controls loop></video></p><p>Another interesting idea: Because colors are interpolated, we could set the
coordinates to somewhere besides a pixel center, in order to get more colors.
For example, the simple 2-by-1 white-to-black texture can also be used to get
any shade of gray.</p></article></main><footer><span class=license>Content is licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA-4.0</a><a class=feed-icon title="RSS feed" href=https://anaminus.github.io/blog/index.xml><svg width="128" height="128" viewBox="0 0 256 256"><path d="m92 189a24 24 0 01-24 24 24 24 0 01-24-24 24 24 0 0124-24 24 24 0 0124 24z"/><path d="m160 213h-34a82 82 0 00-82-82V97a116 116 0 01116 116z"/><path d="M184 213A140 140 0 0044 73V38a175 175 0 01175 175z"/></svg></a></span>
<span class=publication><svg viewBox="0 0 7 7" width="7" height="7"><path d="m2 0v1H1v3h1v3h1V6h1v1h1V4h1V1H5V0H4v1H3V0zm0 2h1v1H2zm2 0h1v1H4z"/></svg> 2022â€“2025 <a href=https://anaminus.github.io/>Anaminus</a></span></footer></body></html>