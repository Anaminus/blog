<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Roblox on Anaminus.Blog</title><link>https://anaminus.github.io/blog/tags/roblox/</link><description>Recent content in Roblox on Anaminus.Blog</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Thu, 22 Jun 2023 12:00:00 +0000</lastBuildDate><atom:link href="https://anaminus.github.io/blog/tags/roblox/index.xml" rel="self" type="application/rss+xml"/><item><title>How the Plugin Marketplace actually works</title><link>https://anaminus.github.io/blog/posts/plugin-marketplace/</link><pubDate>Thu, 22 Jun 2023 12:00:00 +0000</pubDate><guid>https://anaminus.github.io/blog/posts/plugin-marketplace/</guid><description>&lt;h2 id="part-i---the-plugin-compensation-model">Part I - The Plugin Compensation Model&lt;/h2>
&lt;p>You are &lt;strong>developing a game&lt;/strong> on Roblox. Some aspect of your workflow is
lacking, so you write a Studio plugin. This plugin improves the workflow of the
&lt;strong>development of your game&lt;/strong>. You rejoice, as you are able to &lt;strong>develop your
game&lt;/strong> better. The hours put into the development of the plugin are compensated
by the increase in revenue deriving from the plugin allowing you to push out
updates and fixes to your game faster and more efficiently.&lt;/p></description></item><item><title>CFrame mnemonics</title><link>https://anaminus.github.io/blog/posts/cframe-mnemonics/</link><pubDate>Tue, 31 Jan 2023 12:00:00 +0000</pubDate><guid>https://anaminus.github.io/blog/posts/cframe-mnemonics/</guid><description>&lt;h2 id="methods">Methods&lt;/h2>
&lt;p>Certain methods on CFrame have an equivalent operator-based expression, which
can be useful for understanding how they work:&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>Method&lt;/th>
 &lt;th>Expression&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;code>A:ToWorldSpace(B)&lt;/code>&lt;/td>
 &lt;td>&lt;code>A * (B::CFrame)&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>A:ToObjectSpace(B)&lt;/code>&lt;/td>
 &lt;td>&lt;code>A:Inverse() * (B::CFrame)&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>A:PointToWorldSpace(B)&lt;/code>&lt;/td>
 &lt;td>&lt;code>A * (B::Vector3)&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>A:PointToObjectSpace(B)&lt;/code>&lt;/td>
 &lt;td>&lt;code>A:Inverse() * (B::Vector3)&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>A:VectorToWorldSpace(B)&lt;/code>&lt;/td>
 &lt;td>&lt;code>A.Rotation * (B::Vector3)&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>A:VectorToObjectSpace(B)&lt;/code>&lt;/td>
 &lt;td>&lt;code>A:Inverse().Rotation * (B::Vector3)&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="space-conversion-analogy">Space-conversion analogy&lt;/h2>
&lt;p>CFrame multiplication is not equivalent to addition. However, certain aspects
can be reused in order to remember how it works.&lt;/p>
&lt;p>Pretend that &lt;code>A * B&lt;/code> is analogous to &lt;code>B + A&lt;/code>. Also pretend that &lt;code>A:Inverse()&lt;/code> is
analogous to &lt;code>-A&lt;/code>. There is no subtraction, but the formula &lt;code>B - A&lt;/code> can be
rewritten as &lt;code>-A + B&lt;/code>. So, when we see the expression &lt;code>A:Inverse() * B&lt;/code>, it can
be thought of as a sort of &lt;code>B - A&lt;/code>.&lt;/p></description></item><item><title>On CFrame vectors</title><link>https://anaminus.github.io/blog/posts/cframe-vectors/</link><pubDate>Sun, 29 Jan 2023 12:00:00 +0000</pubDate><guid>https://anaminus.github.io/blog/posts/cframe-vectors/</guid><description>&lt;p>In Roblox, the &lt;a href="https://create.roblox.com/docs/reference/engine/datatypes/CFrame">CFrame&lt;/a> type has several &amp;ldquo;Vector&amp;rdquo; fields representing
the directions of various axes of the CFrame. There are two sets of 3 vectors:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://create.roblox.com/docs/reference/engine/datatypes/CFrame#RightVector">RightVector&lt;/a>, &lt;a href="https://create.roblox.com/docs/reference/engine/datatypes/CFrame#UpVector">UpVector&lt;/a>, &lt;a href="https://create.roblox.com/docs/reference/engine/datatypes/CFrame#LookVector">LookVector&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://create.roblox.com/docs/reference/engine/datatypes/CFrame#XVector">XVector&lt;/a>, &lt;a href="https://create.roblox.com/docs/reference/engine/datatypes/CFrame#YVector">YVector&lt;/a>, &lt;a href="https://create.roblox.com/docs/reference/engine/datatypes/CFrame#ZVector">ZVector&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Roblox&amp;rsquo;s documentation claims that these fields represent the rows and columns
of the CFrame&amp;rsquo;s rotation matrix. The X, Y, Z fields are the rows, and the Right,
Up, Look fields are the columns. &lt;strong>This is very significantly incorrect&lt;/strong>.
Inspecting the values of each component reveals it so:&lt;/p></description></item><item><title>Rojo wrangling</title><link>https://anaminus.github.io/blog/posts/rojo-wrangling/</link><pubDate>Mon, 19 Dec 2022 12:00:00 +0000</pubDate><guid>https://anaminus.github.io/blog/posts/rojo-wrangling/</guid><description>&lt;p>I have particular preferences about how I want my projects to be structured, and
I will bend my tools to make it work. This time, the tool being flexed is
&lt;a href="https://rojo.space/">Rojo&lt;/a>.&lt;/p>
&lt;p>I want related modules to be grouped together into one &amp;ldquo;package&amp;rdquo;. If a package
has a server component and a client component, I want those two files to live
next to each other under the same folder. However, there are two problems that
make this structure difficult to have.&lt;/p></description></item><item><title>Managing assets locally</title><link>https://anaminus.github.io/blog/posts/managing-assets-locally/</link><pubDate>Wed, 23 Nov 2022 12:00:00 +0000</pubDate><guid>https://anaminus.github.io/blog/posts/managing-assets-locally/</guid><description>&lt;p>If you&amp;rsquo;re not indoctrinated into the cult of The Cloudâ„¢, then managing assets on
Roblox can be a pain. The assumption seems to be that you&amp;rsquo;re meant to upload
everything and subject it to moderation whether it&amp;rsquo;s ready or not.&lt;/p>
&lt;p>I prefer to keep assets local for as long as possible. Roblox Studio has an
option to hot-reload assets that live on the local file system, which is
absolutely invaluable for fast iteration. Uploading a million variations of
textures that I&amp;rsquo;ll never use ever again doesn&amp;rsquo;t make any sense.&lt;/p></description></item><item><title>Exclusive replication</title><link>https://anaminus.github.io/blog/posts/exclusive-replication/</link><pubDate>Sun, 20 Nov 2022 12:00:00 +0000</pubDate><guid>https://anaminus.github.io/blog/posts/exclusive-replication/</guid><description>&lt;p>Instances in Roblox &lt;strong>replicate&lt;/strong>. That is, a particular instance on the server
will have a copy of itself on each client, and all aspects of this instance are
kept synchronized, including what children it has. In almost all cases, this
replication occurs in one direction only, from server to client.&lt;/p>
&lt;p>Say the server has a red brick in the Workspace. This brick will be replicated
to all clients. When the server changes the brick&amp;rsquo;s color to blue, this change
will be replicated to each client, making their local copy of the brick also
blue. However, when a client tries to change the color of its brick to green,
this change is &lt;em>not&lt;/em> replicated back to the server or any other client. The
change remains local to the client. Moreover, because only changes are
replicated, the server wont constantly be trying to update the brick&amp;rsquo;s color
back to red, so it will remain green, at least until the server changes the
color again.&lt;/p></description></item><item><title>Tiny UVs</title><link>https://anaminus.github.io/blog/posts/tiny-uv/</link><pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate><guid>https://anaminus.github.io/blog/posts/tiny-uv/</guid><description>&lt;p>You want to produce meshes with simple, solid color textures. Because the colors
are solid, you should be able to get away with using small textures. Tiny
textures. Single-digit resolution textures. Possible, right?&lt;/p>
&lt;p>The problem: Roblox applies linear interpolation to its textures. Here is a
2-by-1 Decal, where the left pixel is white, and the right pixel is black:&lt;/p>
&lt;p>&lt;img src="fig1.png" alt="">&lt;/p>
&lt;p>Indeed, the left side is white, and the right side is black, but in between,
there is a smooth, linear interpolation from one pixel to the other.&lt;/p></description></item></channel></rss>