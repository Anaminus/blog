<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Boring-Facts on Anaminus.Blog</title><link>https://anaminus.github.io/blog/tags/boring-facts/</link><description>Recent content in Boring-Facts on Anaminus.Blog</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Wed, 22 Nov 2023 09:36:38 +0000</lastBuildDate><atom:link href="https://anaminus.github.io/blog/tags/boring-facts/index.xml" rel="self" type="application/rss+xml"/><item><title>DataStore keys</title><link>https://anaminus.github.io/blog/briefs/202311220936/</link><pubDate>Wed, 22 Nov 2023 09:36:38 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202311220936/</guid><content:encoded>&lt;p&gt;Boring Facts: DataStore keys are binary-safe. They have a size limit of 50
bytes, not characters. That&amp;rsquo;s 400 full bits to work with.&lt;/p&gt;</content:encoded></item><item><title>Destroying</title><link>https://anaminus.github.io/blog/briefs/202307090002/</link><pubDate>Sun, 09 Jul 2023 00:02:20 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202307090002/</guid><content:encoded>&lt;p&gt;Boring Facts: If Destroying is used to add a child to the destroyed instance,
that child wont be destroyed.&lt;/p&gt;</content:encoded></item><item><title>Input position</title><link>https://anaminus.github.io/blog/briefs/202306272259/</link><pubDate>Tue, 27 Jun 2023 22:59:22 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202306272259/</guid><content:encoded>&lt;p&gt;Boring Facts: The Position of a Keyboard InputObject will update with the
position of the mouse while the key is held down.&lt;/p&gt;
&lt;p&gt;Correction: Only some keys do this, including the arrow keys, Return, Backspace,
and Delete.&lt;/p&gt;
&lt;p&gt;Further correction: this is caused by key repetition. Generally, a keyboard
object will update with the position of the mouse. However, certain keys that
repeat will switch to the End state, then immediately back to the Begin state,
and repeat again while the key is held down.&lt;/p&gt;</content:encoded></item><item><title>Keyboard InputObjects</title><link>https://anaminus.github.io/blog/briefs/202306272255/</link><pubDate>Tue, 27 Jun 2023 22:55:05 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202306272255/</guid><content:encoded>&lt;p&gt;Boring Facts: Keyboard InputObjects are reused per KeyCode, but only while the
current source (e.g. UserInputService or a GUI) is in focus.&lt;/p&gt;</content:encoded></item><item><title>Enum alises</title><link>https://anaminus.github.io/blog/briefs/202302051058/</link><pubDate>Sun, 05 Feb 2023 10:58:34 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202302051058/</guid><content:encoded>&lt;p&gt;Renamed enum items are &amp;ldquo;removed&amp;rdquo; from the API, but still stick around as an
alias to whatever replaced them.&lt;/p&gt;</content:encoded></item><item><title>Archivable</title><link>https://anaminus.github.io/blog/briefs/202208171044/</link><pubDate>Wed, 17 Aug 2022 10:44:34 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202208171044/</guid><content:encoded>&lt;p&gt;Boring Facts: The lowercase &amp;ldquo;archivable&amp;rdquo; property can be used within a model or
place file to load an instance with Archivable set to false.&lt;/p&gt;</content:encoded></item><item><title>NaN preservation</title><link>https://anaminus.github.io/blog/briefs/202207081124/</link><pubDate>Fri, 08 Jul 2022 11:24:00 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202207081124/</guid><content:encoded>&lt;p&gt;Boring Facts: Roblox preserves NaN values across network boundaries.&lt;/p&gt;</content:encoded></item><item><title>UniqueId sequence</title><link>https://anaminus.github.io/blog/briefs/202203181207/</link><pubDate>Fri, 18 Mar 2022 12:07:38 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202203181207/</guid><content:encoded>&lt;p&gt;Boring Facts: UniqueId has one more sequential component that increments every
time an instance is created. If this value manages to overflow, the timestamp
component is updated. To generate a duplicate ID, you would have to produce over
4 billion instances within 1 second.&lt;/p&gt;</content:encoded></item><item><title>GetDebugId</title><link>https://anaminus.github.io/blog/briefs/202203181139/</link><pubDate>Fri, 18 Mar 2022 11:39:23 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202203181139/</guid><content:encoded>&lt;p&gt;Boring Facts: The number returned by GetDebugId is a signed 32-bit integer that
will overflow if more than 2^31 instances have been created.&lt;/p&gt;</content:encoded></item><item><title>UniqueId randomness</title><link>https://anaminus.github.io/blog/briefs/202203180801/</link><pubDate>Fri, 18 Mar 2022 08:01:30 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202203180801/</guid><content:encoded>&lt;p&gt;Boring Facts: The UniqueId type also contains an apparently random sequence of
bytes. However, between serialization in the binary and XML formats, there is a
shift by one bit. &lt;del&gt;It is possible that this is an implementation error.&lt;/del&gt; There
turns out to be no errors. When naively comparing the bytes of the two formats,
they appear to be shifted by one bit. The reason is that, in XML, the random
portion is converted directly to bytes. But in the binary format, zigzag
encoding is used.&lt;/p&gt;</content:encoded></item><item><title>UniqueId timestamp</title><link>https://anaminus.github.io/blog/briefs/202203180739/</link><pubDate>Fri, 18 Mar 2022 07:39:53 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202203180739/</guid><content:encoded>&lt;p&gt;Boring Facts: The UniqueId type found in Roblox place files contains a timestamp
with the epoch set at 2021-01-01. This can be used to determine when an instance
was created, per studio session.&lt;/p&gt;</content:encoded></item></channel></rss>