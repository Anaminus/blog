<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Gamedev on Anaminus.Blog</title><link>https://anaminus.github.io/blog/tags/gamedev/</link><description>Recent content in Gamedev on Anaminus.Blog</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Tue, 12 Aug 2025 15:22:00 +0000</lastBuildDate><atom:link href="https://anaminus.github.io/blog/tags/gamedev/index.xml" rel="self" type="application/rss+xml"/><item><title>Proportional bitmap fonts</title><link>https://anaminus.github.io/blog/briefs/202508121522/</link><pubDate>Tue, 12 Aug 2025 15:22:00 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202508121522/</guid><content:encoded>&lt;p&gt;Here&amp;rsquo;s a method for producing proportional bitmap fonts. The red component
defines the drawable area for each glyph. Green defines the actual appearance.
Blue defines the origin and spacing. Blank glyphs are skipped.&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/briefs/202508121522/00.png" width="1287" height="726" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;Layers are used to define groups of characters, allowing any part of the unicode
codespace to be specified. A layer name with a single code point defines a
sequential group. Ligatures are possible by defining a layer name with more than
one code point.&lt;/p&gt;
&lt;p&gt;Text is rendered by placing the left-most blue pixel of a glyph over the
right-most blue pixel of the previous glyph. Using a baseline instead of
boundaries for glyph placement allows glyphs to be spaced arbitrarily, and even
drawn over each other.&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/briefs/202508121522/01.png" width="1026" height="776" loading="lazy"&gt;&lt;/figure&gt;</content:encoded></item><item><title>RunService</title><link>https://anaminus.github.io/blog/briefs/202309240949/</link><pubDate>Sun, 24 Sep 2023 09:49:55 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202309240949/</guid><content:encoded>&lt;p&gt;If you need to simulate something, such as an assembly, you can call
RunService:Run() and :Stop() from the command bar. It even respects undo/redo.
Keep in mind that the whole place is simulated.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202309240949/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;</content:encoded></item><item><title>Real houses</title><link>https://anaminus.github.io/blog/briefs/202309191037/</link><pubDate>Tue, 19 Sep 2023 10:37:42 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202309191037/</guid><content:encoded>&lt;p&gt;Latest obsession: building houses realistically. Most of it will be abstracted
away in an actual build, but doing it this way informs the layout of the house.
For example, the stairway in this image isn&amp;rsquo;t ideal, because its headroom
conflicts with the roof (1.5-story house).&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/briefs/202309191037/00.jpg" width="1200" height="640" loading="lazy"&gt;&lt;/figure&gt;</content:encoded></item><item><title>Remote signals</title><link>https://anaminus.github.io/blog/briefs/202309160943/</link><pubDate>Sat, 16 Sep 2023 09:43:37 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202309160943/</guid><content:encoded>&lt;p&gt;Remotes effectively break the Signal pattern, so the only thing you should be
doing with them is :Connect()ing exactly one listener.&lt;/p&gt;</content:encoded></item><item><title>Input handling</title><link>https://anaminus.github.io/blog/briefs/202306282139/</link><pubDate>Wed, 28 Jun 2023 21:39:05 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202306282139/</guid><content:encoded>&lt;p&gt;Certain input types have to be handled in certain ways. Key repetitions must be
handled by monitoring the key&amp;rsquo;s InputObject, while mouse wheel input is best
handled by getting it from a source, because an emission from a source doesn&amp;rsquo;t
always correspond to a property change.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202306282139/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;</content:encoded></item><item><title>Input visualizer</title><link>https://anaminus.github.io/blog/briefs/202306272253/</link><pubDate>Tue, 27 Jun 2023 22:53:12 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202306272253/</guid><content:encoded>&lt;p&gt;Widget to visualize how InputObjects are produced. Whenever a new object is
made, it is added to the list, then monitored for changes. Each
Source+UserInputType+KeyCode combination produces its own object. Sources used
are the Input signals from UserInputService and a Frame GUI.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202306272253/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;</content:encoded></item><item><title>Track the mouse</title><link>https://anaminus.github.io/blog/briefs/202306271227/</link><pubDate>Tue, 27 Jun 2023 12:27:26 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202306271227/</guid><content:encoded>&lt;p&gt;A unique advantage of ScrollingFrames over a custom implementation is that the
scrollbar can track the mouse across the entire screen, not just the viewport.&lt;/p&gt;
&lt;p&gt;Correction: This isn&amp;rsquo;t unique: the behavior applies to InputObjects, but only
while a mouse button is held down.&lt;/p&gt;</content:encoded></item><item><title>StudioStyleGuideColor</title><link>https://anaminus.github.io/blog/briefs/202306262146/</link><pubDate>Mon, 26 Jun 2023 21:46:24 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202306262146/</guid><content:encoded>&lt;p&gt;Fusion widget to help narrow down what StudioStyleGuideColor a studio element is
using.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202306262146/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;</content:encoded></item><item><title>Lattice</title><link>https://anaminus.github.io/blog/briefs/202306241601/</link><pubDate>Sat, 24 Jun 2023 16:01:51 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202306241601/</guid><content:encoded>&lt;p&gt;A port of my &amp;ldquo;lattice&amp;rdquo; container GUI to Fusion. Takes a grid of columns and rows
defined as constant pixels or fractional values, and turns them into static
UDim2s. Has options for padding, margins, and a visualizer for debugging.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202306241601/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;</content:encoded></item><item><title>Walk speed</title><link>https://anaminus.github.io/blog/briefs/202304170002/</link><pubDate>Mon, 17 Apr 2023 00:02:01 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202304170002/</guid><content:encoded>&lt;p&gt;Theory: The reason player characters move at different speeds from NPCs is
because the PC has been calibrated on the player&amp;rsquo;s perception. PCs can&amp;rsquo;t move as
slow as NPCs because it would feel sluggish, and NPCs can&amp;rsquo;t move as fast as PCs
because it wouldn&amp;rsquo;t look realistic.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;It occurs to me that twitter will probably silently nuke shit out of this
tweet. If you are one of the lucky few to see it, hi!&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title>WireframeHandleAdornment</title><link>https://anaminus.github.io/blog/briefs/202303171137/</link><pubDate>Fri, 17 Mar 2023 11:37:07 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202303171137/</guid><content:encoded>&lt;p&gt;Tip for using WireframeHandleAdornment: The Color3/Transparency of the adornment
only affects newly added lines, so you only need one adornment to draw lines
with any appearance.&lt;/p&gt;</content:encoded></item><item><title>R-tree</title><link>https://anaminus.github.io/blog/briefs/202303171111/</link><pubDate>Fri, 17 Mar 2023 11:11:04 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202303171111/</guid><content:encoded>&lt;p&gt;Visualization of an r-tree. WireframeHandleAdornment is essential for debugging.&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/briefs/202303171111/00.jpg" width="1200" height="684" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;It&amp;rsquo;s harder to draw shapes, but it&amp;rsquo;s way better than keeping track of a million
handle adornments.&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/briefs/202303171111/01.jpg" width="1200" height="706" loading="lazy"&gt;&lt;/figure&gt;</content:encoded></item><item><title>ProximityPrompts</title><link>https://anaminus.github.io/blog/briefs/202301191334/</link><pubDate>Thu, 19 Jan 2023 13:34:33 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202301191334/</guid><content:encoded>&lt;p&gt;ProximityPrompts make for great general proximity detectors.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202301191334/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;The proximity signals are client-only, so validation is still required. But it’s
a fast and simple solution for detection. I like to think that it’s been
optimized for large numbers of prompts spread across the workspace, so it’d be a
winner in that case.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Author&amp;rsquo;s Note: The tweet this post was derived from was blessed by The
Algorithm for some reason.&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title>RemoveEvent:Once()</title><link>https://anaminus.github.io/blog/briefs/202301161535/</link><pubDate>Mon, 16 Jan 2023 15:35:04 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202301161535/</guid><content:encoded>&lt;p&gt;Using &lt;code&gt;:Once()&lt;/code&gt; on a RemoteEvent will cause the first queued event to be
received and all other queued events to be discarded.&lt;/p&gt;
&lt;p&gt;This is a design flaw: connecting to a signal must not fire the signal, which
remotes do. To avoid losing events, the workaround is to enforce a remote to
have exactly one consumer. By this logic, &lt;code&gt;:Once()&lt;/code&gt; isn’t allowed, because it
adds the one consumer then immediately removes it.&lt;/p&gt;
&lt;p&gt;The problem is that connecting to the signal fires it and drains the queue. You
literally cannot connect multiple listeners without one of them missing the
queued events. The only option is a wrapper with one listener that dispatches to
multiple listeners.&lt;/p&gt;
&lt;p&gt;There are several solutions to the problem. The most backward compatible would
be to trigger the dequeue on the first connection as usual, but defer it so that
other connections in the same frame have a chance to connect.&lt;/p&gt;</content:encoded></item><item><title>Streaming</title><link>https://anaminus.github.io/blog/briefs/202301090959/</link><pubDate>Mon, 09 Jan 2023 09:59:23 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202301090959/</guid><content:encoded>&lt;p&gt;A problem with streaming on Roblox is that a client can just move the camera
anywhere, and the server will happily stream whatever is at that location, even
if the player is not meant to be there. Developers need to be able to exclude
areas from being streamed to certain clients.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023-01-16 23:14&lt;/em&gt;: As a follow up, it turns out to be possible with the
Player.ReplicationFocus property. Setting it to a dummy part gives the server
the opportunity to deny streaming in. The position of the dummy part matches the
character, except when the character moves to an undesired location.&lt;/p&gt;</content:encoded></item><item><title>1-bit LÖVE</title><link>https://anaminus.github.io/blog/briefs/202212300234/</link><pubDate>Fri, 30 Dec 2022 02:34:12 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202212300234/</guid><content:encoded>&lt;p&gt;Having some fun with LÖVE.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202212300234/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;Here&amp;rsquo;s a view of the chunk buffer demonstrating simplified chunk loading:&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202212300234/01.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;The white area is the viewport. Chunks are updated only when the focus leaves
the yellow area. Each corner of the blue area determines which chunks are
loaded.&lt;/p&gt;</content:encoded></item><item><title>Punishing players</title><link>https://anaminus.github.io/blog/briefs/202212080955/</link><pubDate>Thu, 08 Dec 2022 09:55:35 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202212080955/</guid><content:encoded>&lt;p&gt;It&amp;rsquo;s current year and we&amp;rsquo;re still hell-bent on punishing players for not playing
our games correctly instead of just shoving them into their own world where they
can play however they like.&lt;/p&gt;</content:encoded></item><item><title>Foliage</title><link>https://anaminus.github.io/blog/briefs/202209292251/</link><pubDate>Thu, 29 Sep 2022 22:51:14 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202209292251/</guid><content:encoded>&lt;p&gt;Playing with foliage. Here we have the same texture, triangle count, and
triangle size, but different scaling of the base shape, which is a sphere in
this case. Unfortunately, it&amp;rsquo;s hard to get something that looks good without
fine-tuning each of these parameters.&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/briefs/202209292251/00.jpg" width="1200" height="675" loading="lazy"&gt;&lt;/figure&gt;</content:encoded></item><item><title>Cartridge</title><link>https://anaminus.github.io/blog/briefs/202209240907/</link><pubDate>Sat, 24 Sep 2022 09:07:49 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202209240907/</guid><content:encoded>&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202209240907/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;</content:encoded></item><item><title>Tiny UVs</title><link>https://anaminus.github.io/blog/posts/tiny-uv/</link><pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate><guid>https://anaminus.github.io/blog/posts/tiny-uv/</guid><description>Making minimal and efficient UVs in Blender for Roblox.</description><content:encoded>&lt;p&gt;You want to produce meshes with simple, solid color textures. Because the colors
are solid, you should be able to get away with using small textures. Tiny
textures. Single-digit resolution textures. Possible, right?&lt;/p&gt;
&lt;p&gt;The problem: Roblox applies linear interpolation to its textures. Here is a
2-by-1 Decal, where the left pixel is white, and the right pixel is black:&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/posts/tiny-uv/fig1.png" width="300" height="200" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;Indeed, the left side is white, and the right side is black, but in between,
there is a smooth, linear interpolation from one pixel to the other.&lt;/p&gt;
&lt;p&gt;When constructing UVs for a mesh, we&amp;rsquo;ll have to find a way around this. Let&amp;rsquo;s
head over to Blender, and work on a simple plane mesh:&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/posts/tiny-uv/fig2.png" width="997" height="618" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;The interpolation of the texture should be set to &lt;strong&gt;Linear&lt;/strong&gt;, and the extension
should be set to &lt;strong&gt;Repeat&lt;/strong&gt;. This will match how Roblox renders textures on
MeshParts. When we import it into Roblox, it looks mostly similar:&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/posts/tiny-uv/fig3.png" width="300" height="200" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;Notably, the left side begins to fade towards black, while the right side fades
towards white, which proves that the texture repeats. So we&amp;rsquo;ll be able to use
Blender to get a rough idea of what Roblox will render.&lt;/p&gt;
&lt;p&gt;So how do we produce solid colors? We can&amp;rsquo;t just cover the whole pixel with a
face, because half of the pixel is always interpolating to its neighbor:&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/posts/tiny-uv/fig4.png" width="997" height="618" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;To get a solid color, the coordinates have to be in the exact center of the
pixel:&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/posts/tiny-uv/fig5.png" width="997" height="618" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;Two faces, each using one color:&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/posts/tiny-uv/fig6.png" width="997" height="618" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;But does it work in Roblox?&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/posts/tiny-uv/fig7.png" width="830" height="508" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;Indeed! To compare the colors, the top squares are regular Parts, while the
bottom squares are the mesh.&lt;/p&gt;
&lt;p&gt;UV coordinates are reused for SurfaceAppearance textures, so this technique can
be used to set the roughness and metalness of surfaces as well:&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/posts/tiny-uv/fig8.png" width="830" height="508" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; To set the coordinates of many faces at once, select all the faces, use
the scale tool, and set the scale amounts to 0. This will move all vertices to a
single location, which you can then move to the center of the desired pixel.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/posts/tiny-uv/fig9.webm" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;Another interesting idea: Because colors are interpolated, we could set the
coordinates to somewhere besides a pixel center, in order to get more colors.
For example, the simple 2-by-1 white-to-black texture can also be used to get
any shade of gray.&lt;/p&gt;</content:encoded></item><item><title>Gamejam</title><link>https://anaminus.github.io/blog/briefs/202208281404/</link><pubDate>Sun, 28 Aug 2022 14:04:45 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202208281404/</guid><content:encoded>&lt;p&gt;Not at RDC, but I thought I&amp;rsquo;d gamejam anyway. Didn&amp;rsquo;t finish, but I still had
fun. Here&amp;rsquo;s what would have been the thumbnail:&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/briefs/202208281404/00.jpg" width="1024" height="1024" loading="lazy"&gt;&lt;/figure&gt;&lt;p&gt;If you&amp;rsquo;re going to solojam, try to use existing assets as much as possible. I
modeled the car, sun, and skybox from scratch, which was fun to do, but sunk way
too much time.&lt;/p&gt;</content:encoded></item><item><title>Grass</title><link>https://anaminus.github.io/blog/briefs/202207111221/</link><pubDate>Mon, 11 Jul 2022 12:21:19 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202207111221/</guid><content:encoded>&lt;p&gt;Physically simulated grass.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202207111221/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;Single triangle rigged with two bones. Lower bone is attached to a colliding
part via BallSocket. Upper bone has a VectorForce to keep the whole thing
upright, and an AngularVelocity to introduce some instability that simulates
wind.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202207111221/01.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;Some translucency can be simulated by rotating the upper bone by 180 degrees,
which also rotates the normal of the top vertex.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202207111221/02.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;One MeshPart can be rigged to fit up to 128 grass units, whereas Beams would
have to be 1:1. But in terms of visuals, Beams have much more to offer than
Decals.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202207111221/03.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;A texture can be used, but artifacts occur on the upper edge because the texture
wraps around and repeats.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202207111221/04.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;blockquote&gt;
&lt;p&gt;you can get around this using the TextureLength property&lt;/p&gt;
&lt;p&gt;&amp;mdash; &lt;a href="https://twitter.com/ChrythmDev/status/1547708323180343296"&gt;@ChrythmDev, 10:23 PM · Jul 14, 2022&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I guess that works, but the texture has to be upside down.&lt;/p&gt;
&lt;p&gt;On whether using beams is practical: disregarding physics, most of the time goes
into updating beam logic. Actual rendering is sub-optimal, but it isn&amp;rsquo;t the
bottleneck. Not sure what causes LOD cutoff (it&amp;rsquo;s not affected by graphics
settings). Might be a memory thing.&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/briefs/202207111221/05.jpg" width="1200" height="675" loading="lazy"&gt;&lt;/figure&gt;</content:encoded></item><item><title>Rigging</title><link>https://anaminus.github.io/blog/briefs/202207081638/</link><pubDate>Fri, 08 Jul 2022 16:38:11 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202207081638/</guid><content:encoded>&lt;p&gt;I rigged a mesh that has 85 completely independent triangles. Used it for
efficiently generating light rays:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.roblox.com/library/9287415204"&gt;https://www.roblox.com/library/9287415204&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I also rigged one for 256 independent squares:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.roblox.com/library/9288565775"&gt;https://www.roblox.com/library/9288565775&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title>Particle grass</title><link>https://anaminus.github.io/blog/briefs/202206291048/</link><pubDate>Wed, 29 Jun 2022 10:48:24 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202206291048/</guid><content:encoded>&lt;p&gt;Infeasible particle grass.&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/briefs/202206291048/00.jpg" width="1097" height="630" loading="lazy"&gt;&lt;/figure&gt;</content:encoded></item><item><title>Unreliable physics</title><link>https://anaminus.github.io/blog/briefs/202206261949/</link><pubDate>Sun, 26 Jun 2022 19:49:10 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202206261949/</guid><content:encoded>&lt;p&gt;Stupid idea: send/receive unreliable data by encoding it in physics.&lt;/p&gt;</content:encoded></item><item><title>From scratch</title><link>https://anaminus.github.io/blog/briefs/202205081446/</link><pubDate>Sun, 08 May 2022 14:46:10 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202205081446/</guid><content:encoded>&lt;p&gt;Making from scratch isn&amp;rsquo;t as fun. Better to take an existing thing and make it
do something else. My first experience with Roblox Lua was turning a jetpack
into a sword.&lt;/p&gt;</content:encoded></item><item><title>Easter eggs</title><link>https://anaminus.github.io/blog/briefs/202204301952/</link><pubDate>Sat, 30 Apr 2022 19:52:08 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202204301952/</guid><content:encoded>&lt;p&gt;Stop making easter eggs just to tell everyone about them. Those aren&amp;rsquo;t easter
eggs.&lt;/p&gt;</content:encoded></item><item><title>Greedy skinned meshes</title><link>https://anaminus.github.io/blog/briefs/202204051312/</link><pubDate>Tue, 05 Apr 2022 13:12:57 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202204051312/</guid><content:encoded>&lt;p&gt;Using skinned meshes instead of parts to reduce the part count for Boatbomber&amp;rsquo;s
&lt;a href="https://github.com/boatbomber/ViewportCanvas"&gt;ViewportCanvas&lt;/a&gt;. Unfortunately, the initial rendering takes way too long to
be feasible.&lt;/p&gt;
&lt;figure&gt;&lt;img src="https://anaminus.github.io/blog/briefs/202204051312/00.jpg" width="1003" height="519" loading="lazy"&gt;&lt;/figure&gt;</content:encoded></item><item><title>LocalAssetsFolder</title><link>https://anaminus.github.io/blog/briefs/202203092220/</link><pubDate>Wed, 09 Mar 2022 22:20:31 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202203092220/</guid><content:encoded>&lt;p&gt;Protip: Search for GlobalSettings_13.xml in your file system. This contains
settings for Studio. If you set the &amp;ldquo;LocalAssetsFolder&amp;rdquo; setting to a directory,
files in that directory can be accessed through &lt;code&gt;rbxasset://&lt;/code&gt;. Use this to work
on audio before uploading it.&lt;/p&gt;</content:encoded></item><item><title>Sun rays Mk II</title><link>https://anaminus.github.io/blog/briefs/202202211845/</link><pubDate>Mon, 21 Feb 2022 18:45:36 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202202211845/</guid><content:encoded>&lt;p&gt;Sun rays with much better performance.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202202211845/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;Lot to unpack here. Each ray is a triangle within a MeshPart. Each MeshPart
groups together 85 triangles. Each vertex has a corresponding Bone, so the
triangles can be positioned independently and arbitrarily. Rays are produced by
allocating tris from the 85-tri meshes. A new MeshPart is created once all the
tris from the previous MeshPart are used.&lt;/p&gt;
&lt;p&gt;The ForceField material is utilized here. As previously mentioned, the
orientation of vertex normals affects the appearance of the force field. Each
vertex corresponds to a bone. For each tri, one of the bones is designated as a
&amp;ldquo;roller&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;The roller bone is moved out of the MeshPart into a separate Part that is
attached with a BallSocketConstraint at the original location. This part has
another attachment with a randomized orientation. This randomized attachment is
assigned to an AlignOrientation.&lt;/p&gt;
&lt;p&gt;The other end of the AlignOrientation is assigned to a single attachment. The
brick in the video contains this attachment. The rotation of this brick is
directly controlling the &amp;ldquo;movement&amp;rdquo; of the rays.&lt;/p&gt;
&lt;p&gt;The extra attachment with the randomized orientation is necessary so that the
appearance of force fields are spread out and unaligned. Assemblies with
BallSockets are necessary so that the bones are detected correctly while
allowing free orientation.&lt;/p&gt;
&lt;p&gt;Now that I think about, the whole thing is driven entirely by physics. The only
script running continuously is to rotate the brick, but that&amp;rsquo;s only because the
AngularVelocity constraint was being finicky.&lt;/p&gt;
&lt;p&gt;Driving the control brick through physics doesn&amp;rsquo;t work well, because the rollers
seem to fall asleep or otherwise get stuck. Updating it via script seems to keep
them awake.&lt;/p&gt;</content:encoded></item><item><title>Sun rays</title><link>https://anaminus.github.io/blog/briefs/202202201547/</link><pubDate>Sun, 20 Feb 2022 15:47:20 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202202201547/</guid><content:encoded>&lt;p&gt;Sun rays.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202202201547/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;Each ray is just a stretched cube mesh with an almost transparent ForceField
material. The mesh is just for surface smoothing, so a simple Union could be
used as well, though it&amp;rsquo;s less convenient to resize. Each part is rotated
continuously.&lt;/p&gt;
&lt;p&gt;Rays are cast from a defined plane using GetSunDirection, so some occlusion can
be achieved.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202202201547/02.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;In practice, it seems like using meshes and ForceFields is excessive. Regular
transparent parts seem to produce more or less the same effect.&lt;/p&gt;
&lt;p&gt;Retrying with a simple triangle mesh has much better performance. An interesting
side-effect of using a mesh with bones is that the shape and appearance of the
ForceField can be controlled by the vertex normals.&lt;/p&gt;
&lt;p&gt;Rotating the vertex normals instead of the part produces a subtle
rolling-fog-like effect. Not sure if it will show up in the video, but it&amp;rsquo;s
really cool. Unfortunately, the performance is awful. Bone modification doesn&amp;rsquo;t
seem to be as optimized as it could be.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202202201547/01.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;According to the profiler, modifying a Bone&amp;rsquo;s CFrame once involves 27 instances
of &amp;ldquo;Loader&amp;rdquo;, each involving a call to &amp;ldquo;IsA&amp;rdquo;. Definitely doesn&amp;rsquo;t seem right.&lt;/p&gt;
&lt;p&gt;Apparently the ForceField material can be affected by vertex color alphas, but
Blender doesn&amp;rsquo;t support them???&lt;/p&gt;
&lt;p&gt;A further optimization is to have multiple triangles per MeshPart. A mesh can
have up to 256 bones, which amounts to 85 triangles. This reduces the above
scene of ~400 parts down to just 6.&lt;/p&gt;</content:encoded></item><item><title>Ripples</title><link>https://anaminus.github.io/blog/briefs/202202022336/</link><pubDate>Wed, 02 Feb 2022 23:36:29 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202202022336/</guid><content:encoded>&lt;p&gt;Tried a ripple effect.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202202022336/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;</content:encoded></item><item><title>Production logos</title><link>https://anaminus.github.io/blog/briefs/202202011022/</link><pubDate>Tue, 01 Feb 2022 10:22:52 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202202011022/</guid><content:encoded>&lt;p&gt;Production logo sequencer.&lt;/p&gt;
&lt;figure&gt;&lt;video src="https://anaminus.github.io/blog/briefs/202202011022/00.mp4" controls loop&gt;&lt;/video&gt;&lt;/figure&gt;&lt;p&gt;First logo is actually 3D to avoid loading assets. On the other hand, the next
logo loads over 500 assets; the previous logo will wait until the next logo is
finished loading. The second run of the sequence demonstrates skipping via user
input.&lt;/p&gt;</content:encoded></item><item><title>Query plugin</title><link>https://anaminus.github.io/blog/briefs/202201191349/</link><pubDate>Wed, 19 Jan 2022 13:49:40 +0000</pubDate><guid>https://anaminus.github.io/blog/briefs/202201191349/</guid><content:encoded>&lt;p&gt;Lately I&amp;rsquo;ve been getting a lot of mileage out this selection querying plugin I
made:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Anaminus/roblox-library/blob/master/plugins/Utilities/q.lua"&gt;https://github.com/Anaminus/roblox-library/blob/master/plugins/Utilities/q.lua&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s based on Lua expressions (with some extra syntax), so it&amp;rsquo;s very versatile.&lt;/p&gt;</content:encoded></item></channel></rss>